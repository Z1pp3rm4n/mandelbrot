\documentclass{article} 
\usepackage[german]{babel}
\usepackage[style=numeric,backend=biber]{biblatex}
\addbibresource{refs.bib}

\usepackage{listings}
\usepackage{xcolor}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
	backgroundcolor=\color{backcolour},   
	commentstyle=\color{codegreen},
	keywordstyle=\color{magenta},
	numberstyle=\tiny\color{codegray},
	stringstyle=\color{codepurple},
	basicstyle=\ttfamily\footnotesize,
	breakatwhitespace=false,         
	breaklines=true,                 
	captionpos=b,                    
	keepspaces=true,                 
	numbers=left,                    
	numbersep=5pt,                  
	showspaces=false,                
	showstringspaces=false,
	showtabs=false,                  
	tabsize=2
}

\lstset{style=mystyle}

\usepackage{graphicx}
\usepackage{amsmath} % 

\title{Mandelbrot \& Julia-Mengen: Ein Fraktale-Visualisierungsprogramm} % Sets article title
\author{Tuan Vinh Nguyen} % Sets authors name
\date{\today} % Sets date for date compiled

% The preamble ends with the command \begin{document}
	\begin{document} % All begin commands must be paired with an end command somewhere
		\maketitle % creates title using information in preamble (title, author, date)
		
\section{Mandelbrot und Julia-Mengen}
\subsection{Definitionen}
Das Bild der Mandelbrot-Menge soll jeder bekannt sein. Es taucht oft in der Mathematik auf, und manchmal sogar in der Popkultur.
\begin{figure}[!htb]
\centering
\includegraphics[width=\linewidth]{img/mandelbrot_fullres}
\caption{Die Mandelbrot Menge, generiert mit unserem Programm}
\label{fig:mandelbrotfullres}
\end{figure}
Was weniger bekannt ist, ist die Bedeutung des obigen Diagramms: 
\begin{itemize}
\item Jeder Pixel $(x,y)$ wird als eine komplexe Zahl $c = x + i.y$ interpretiert.
\item Die Funktion $f(z) = z^2 +c$ wird auf den Startwert $z=0$ angewendet, sodass eine Folge $z_0, z_1, ..., z_n = 0, f(0), f(f(0)),...$ entsteht.
\item Man betrachtet dann die Beträge $|z_n|$ von Zahlen in der Folge. Die können bis ins Unendliche wachsen, z.B mit $c=2$, die Folge ist: $0,2,6,38,1446,2090918, ...$ Im Gegenteil können sie für bestimmte Werte von $c$ immer unter einer Grenze bleiben. Man sagt dann, dass $c$ in der Mandelbrot-Menge liegt, und die entsprechenden Pixel werden schwarz gefärbt. \cite{wiki-mandelbrot}
\end{itemize}
Obwohl die Funktion $f$ an sich nicht so kompliziert ist, gibt es keine allgemeinen Formeln, die bestimmen können, ob eine Zahl in der Mandelbrot ist. Sehr kleine Änderungen bei dem Wert von $c$ führen oft zu chaotischen Änderungen bei $z_n$, die nicht vorhersagen lassen. Das daraus entstehende Fraktal enthält deswegen sehr komplizierte Muster, und manchmal auch sich selbst (sehe: Abb. \ref{fig:mandelbrotmini}, \ref{fig:spiralen}, \ref{fig:blatt})

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{img/mandelbrot_mini}
\caption{Ein Mini-Mandelbrot innerhalb des Mandelbrots}
\label{fig:mandelbrotmini}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{img/spirale}
\caption{Unendliche Spiralen im Mandelbrot}
\label{fig:spiralen}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{img/blatt}
\caption{Ein Blatt mit Zweigen im Mandelbrot}
\label{fig:blatt}
\end{figure}

Analog zu der Mandelbrot-Menge wird auch bei Julia-Mengen $f_c$ iterativ auf $z$ angewendet. Diesmal legt man $c$ fest und ändert den Startwert $z$. Punkte, bei der kleine Änderungen zu chaotischen Entwicklungen führen, gehören zur Menge. Grafisch liegen dann Punkte der Julia-Menge an den Grenzen (z.B. in Abb. \ref{fig:julia-set}: zwischen die schwarzen und blauen Bereichen) 

Allgemein lassen Julia-Mengen sich durch eine Funktion $f(z): C \rightarrow C$ beschreiben, wobei die Funktion nicht unbedingt der Form $f(z) = z^2 +c$ haben muss.

\begin{figure}[!htb]
\centering
\includegraphics[width=0.7\linewidth]{img/julia-set}
\caption{Die Julia Menge mit $f(z) = z^2 +c$, wobei $c \approx (-0.7022, 0.0089)$. Die Punkte der Menge sind an der Grenze zwischen Schwarz und Blau.}
\label{fig:julia-set}
\end{figure}


\subsection{Ziele des Projekts}	
Um diese Mengen bzw. Fraktale zu untersuchen, ist ein Visualisierungsprogramm, bei dem man heran- und herauszoomen kann, meiner Ansicht nach am bestens geeignet. Der Zoomer soll auch in Echtzeit funktionieren, d.h: es muss mit $\approx 30$ FPS laufen können. Obwohl Python nicht gerade als eine Performanz-Programmiersprache bekannt ist, können wir uns mithilfe einiger Optimierungen und des Xaos-Algorithmus diesem Ziel nähern. In nächster Sektion werden diese Algorithmen sowie deren Implementierungen im Programm genau erläutert.

\section{Implementierung}
\subsection{Allgemeines Verfahren}
Im Grunde genommen brauchen wir 3 Schritte, um das Mandelbrot zu rendern:
\begin{itemize}
\item Pixels auf komplexe Zahlen abbilden (trivial)
\item Iterationenanzahl \lstinline|iter| berechnen
\item Farbe aus \lstinline|iter| berechnen
\end{itemize}
Der hier gegebene Code ist eine vereinfachte Version und kann vom tatsächlichen Programm abweichen. Es gibt auch einen Jupyter-Notebook, in dem Sie den Code selber ausführen können.

\subsection{Iterationenanzahl berechnen}
Es ist bekannt, dass keine komplexen Zahlen $z = x + yi$ mit Betrag $|z| = x^2 + y^2 \geq 2$ in der Mandelbrot-Menge liegen. D.h, wir müssen nur $z = z^2 + c$  anwenden, bis $|z|$ unsere Schranke überschreitet. Wenn nach \lstinline|max_iter| Iterationen der Betrag $|z|$ noch nicht explodiert, sagen wir, dass $c$ in der Mandelbrot-Menge ist. 

Je größer \lstinline|max_iter| ist, desto detaillierter wird das Fraktal, aber dafür müssen auch mehr gerechnet werden. 
\begin{lstlisting}[language=Python, caption={Eine Schleife zur Berechnung der Iterationenanzahl}, captionpos=b] 
def find_iter(cx, cy):
	zx, zy = 0.0, 0.0
	iter = 0
	while iter < max_iter and zx**2 + zy**2 < 4:
		iter += 1
		zx_old = zx
		zx = zx**2 - zy**2 + cx
		zy = 2*zx_old*zy + cy
return iter
\end{lstlisting}
\begin{itemize}
\item Gemäß dem Formel ist der Realteil $zx = zx^2 - zy^2 + cx$, $zy = 2*zx*zy + cy$, wobei $z$ mit Wert $0$ startet und $c$ unserer Parameter ist. 
\item Nach jeder Schleife wir geprüft, oft $\sqrt{zx^2 + zy^2} < 2$ bzw. $zx^2 + zy^2 < 4$
\end{itemize}

Färben wir nun die Punkte $c$ in Graustufen, je nach wie schnell $|z|$ über den Fluchtradius gehen (\lstinline|iter|), haben wir ein Bild vom Fraktal.

\begin{lstlisting}[language=python, caption={Ergebnis in Abb. \ref{fig:mandelbrot-numpy} }, captionpos=b]
def render_numpy(width, height, max_iter):
    image = np.full((width, height, 3), [0,0,0], dtype=np.uint32)
    xcoords = np.linspace(-2, 2, width, dtype=np.float64)
    ycoords = np.linspace(-1, 1, height, dtype=np.float64)
    for x in range(width):
        for y in range(height):
            cx = xcoords[x]
            cy = ycoords[y]
            iter = find_iter(cx,cy,max_iter)
            col = 0 if iter == max_iter else int(iter / max_iter * 255)
            image[x,y] = [col,col,col]
    
    return image

image = render_numpy(400,200, max_iter=100)
plt.imshow(np.swapaxes(image, 0, 1))
plt.show()
\end{lstlisting}
\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{img/mandelbrot-numpy}
	\caption{Ein Bild der Mandelbrot-Menge mit Auflösung 400x200, Laufzeit: 1.5  Sekunden}
	\label{fig:mandelbrot-numpy}
\end{figure}
In weniger als 30 Zeilen haben wir die Mandelbrot-Menge visualisiert! Aber ein großes Problem ist zu lösen: Geschwindigkeit. Für nur ein 800x400 Auflösung Bild brauchte mein Laptop 1.5 Sekunde. Das Ziel ist aber, mit 1920x1080 Auflösung, in $\sim 1/30$ einer Sekunde dies zu berechnen. Also \textbf{Parallelisierung} ist gebraucht. 

Natürlich können wir die obige Funktion vektorisieren, sodass es auf den ganzen Array arbeitet, anstatt eine Schleife auf alle Elementen, aber ich möchte den Algorithmus minimal modifizieren und trotzdem dessen Performanz steigen. Mithilfe von \textbf{taichi} wurde der obige Code um fast 80-Mal beschleunigt. Demnächst muss aber erklärt werden, wie Taichi funktioniert.

\subsubsection{Taichi: Eine schnelle Einführung}
Taichi ist nicht nur ein Modul, sondern eine parallele Programmiersprache, die zusammen mit Python arbeiten kann. Unterschiedliche Backends können benutzt werden, z.B \lstinline|ti.cpu| für die CPU oder \lstinline|ti.gpu| für CUDA/Vulkan basierte Grafikkarten. Die Syntax von Taichi ist ähnlich wie die von Python, nun mit einigen kleinen Unterschieden und Konzepten:·

\begin{itemize}
	\item Taichi Kernel (bezeichnet mit \lstinline|@ti.kernel|) sind Funktionen, die rechenintensive Aufgaben erledigen können, indem innere Schleifen automatisch parallelisiert werden. Eine Python-Funktion kann Taichi Kernel aufrufen aber nicht umgekehrt. Taichi Kernel können nur Taichi Funktionen aufrufen (\lstinline|@ti.func|). Ein typischer Workflow wäre:
	\begin{lstlisting}[language=python]
		@ti.kernel
		def taichi_kernel():
		for i in range(1000000): # Parallelisiert
			mach_etwas_schweres()

		ti.init(arch=ti.gpu) # Benutzt das GPU 
		... # Normaler Python-Code
		taich_kernel() 
	\end{lstlisting}

	\item Analog zu \lstinline|numpy| Arrays arbeitet Taichi Code oft mit Fields.	
	\begin{lstlisting}[language=python]
		x = ti.Field(dtype=ti.float64, shape=(50,40))
		# Ein 50x40 Feld mit 64-Bits-Gleitkommazahlen
		x[0,30] = 4 # 0-te Reihe, 30-te Spale
		x[0,14] = x[0,13] + x[1,3]
	\end{lstlisting}
	
	\item Globale Variablen sind bei Taichi-Kerneln konstant, also mutable Variablen müssen explizit als Parameter übergeben werden. Außerdem ist der Typ von Variablen zu annotieren
		\begin{lstlisting}[language=python]
		x = 5
		@ti.kernel
		def print_wrong():
			print(x)
		x = 20
		kernel_print(x) # Ausgabe: 5 (Fehler)
		
		@ti.kernel
		def print_right(x: int):
			print(x) # Ausgabe:20 (Korrekt)
	\end{lstlisting}
	
	\item Taichi Funktionen können keine Arrays/Fields erstellen
		\begin{lstlisting}[language=python]
		def python_func():
			array = np.zeros(shape=(50,40), dtype=np.int32)
			taichi_kernel(array)
		
		@ti.kernel
		taichi_kernel(ti.types.ndarray()):
			for i in array:
				array[i] = mach_etwas_schweres(i)
	\end{lstlisting}
\end{itemize}
Für mehr Informationen: sehe Taichi-Docs \cite{taichi}. Nun jetzt sind wir bereit, mithilfe von Taichi parallelen Code zu schreiben

\begin{lstlisting}[language=python]
ti.init(arch=ti.gpu) # Benutz GPU als Backend
def render_taichi(width, height, max_iter):
	image_field = ti.Vector.field(n=3, shape=(width,height), dtype=ti.uint32)
	xcoords = np.linspace(-2,2,width)
	ycoords = np.linspace(-1,1,height)
	render_kernel(image_field, xcoords, ycoords, max_iter)
	return image_field.to_numpy()

@ti.kernel
def render_kernel(image_field:ti.template(), xcoords: ti.types.ndarray(), ycoords: ti.types.ndarray(), max_iter: int): 
	for x,y in image_field: # paralellisiert
		cx = xcoords[x]
		cy = ycoords[y]
		iter = find_iter_taichi(cx,cy, max_iter)
		col = 0 if iter==max_iter else int(iter / max_iter *255)
		image_field[x,y] = [col,col,col]

# Der erster Lauf des Codes kann langsam sein
# Sequentielle Laeufe werden schneller
image = render_taichi(1600, 800, max_iter=100)
plt.imshow(np.swapaxes(image, 0, 1))
plt.show()
\end{lstlisting}
\begin{figure}[!htb]
	\centering
	\includegraphics[width=\linewidth]{img/mandelbrot-taichi}
	\caption{Ein Bild der Mandelbrot Menge mit Auflösung 1600x800, Laufzeit: 0.3 Sekunden mit Taichi}
	\label{fig:mandelbrot-taichi}
\end{figure}
Die fundamentale Schleife ist fast nicht geändert, aber wir können ein Bild, das 16 Mal detaillierter ist, in ein Fünftel der Zeit berechnen. (Abb. \ref{fig:mandelbrot-taichi})

\subsection{Farbe}
Natürlich sind Schwarz-Weiß Bilder ausreichend, aber die sind noch zu langweilig. Außerdem, wenn wir den \lstinline|max_iter| zu hoch setzen, z.B 2000, bekommen wir ein nahezu komplett schwarzes Bild. Die meisten Punkten divergieren schon mit einer niedrigen Iterationenanzahl, also deren Helligkeit \lstinline|iter/max_iter| geht gegen 0. (Abb. \ref{fig:highmaxiter})

\begin{figure}[!htb]
\centering
\includegraphics[width=\linewidth]{img/high_max_iter}
\caption{Mandelbrot mit \lstinline|max_iter| = 2000}
\label{fig:highmaxiter}
\end{figure}

\subsubsection{Palette automatisch generieren}
Eine mögliche Implementation wäre die Benutzung einer Palettendatei bzw. Palettenarray. Um die Farbe von einem Punkt zu bekommen, muss man nur den entsprechenden Eintrag \lstinline|palette_array[iter]| zugreifen, was sehr effizient ist. Allerdings kann diese Vorgehensweise eine nicht-ganzzahlige Iterationenanzahl nicht behandeln (\textit{die bekommt man durch Normalisierung, mehr im nächsten Kapitel}). Stattdessen können wir mithilfe einer simplen Formel eine kontinuierliche Palette generieren:
$$color(t) = a + b \cdot cos[ 2\pi(c \cdot t+d)] $$
a, b, c, d und Ergebnis color(t) sind RGB-Vektoren mit Werten im Bereich (0,1). Geht t von 0 bis 1, schwingt der Cosinus-Teil $c$-Mal mit Startphase $d$, $a$ und $b$ sind der Bias- bzw Skalierungsfaktor \cite{quilez}. 

\begin{figure}[!htb]
\centering
\includegraphics[width=\linewidth]{img/beispiel_palette}
\caption{Regenbogen-Palette mit $a=(0.5,0.5,0.5), b=(0.5, 0.5, 0.5), c=(1.0, 1.0, 1.0), d=(0.00, 0.33, 0.67)$}
\label{fig:beispielpalette}
\end{figure}

Setzen wir \lstinline|t=iter/max_iter| in den Formel, bekommen wir ein gefärbtes Bild der Mandelbrot in Abbildung \ref{fig:mandelbrot_palette}

\begin{figure}[!h]
\centering
\includegraphics[width=\linewidth]{img/automatische_palette}
\caption{Mandelbrot mit Palette $a=(0.5,0.5,0.5), b=(0.5,0.5,0.5),c=(1.0,1.0,1.0),d=(0.5,0.60,0.70)$}
\label{fig:mandelbrot_palette}
\end{figure}

\subsubsection{Kontinuierlich Farbverläufe}
Zoomen wir ein bisschen in die obige Abbildung, fällt etwas auf: separate ``Farbstreifen`` entstehen im Bild (Abb. \ref{fig:farbstreifen}). Grund dafür ist, dass Punkte nur ganzzahlige Farbstufen (\lstinline|iter|) haben. Deswegen gibt es eine abrupte Transition z.B: zwischen Regionen mit \lstinline|iter = 1| und Regionen mit \lstinline|iter = 2|. Dieses Problem lässt sich lösen, wenn dazwischen mit Punkten mit \lstinline|iter = 1.1, 1.2, 1.3,...| gefüllt wird. Dies schafft man durch \textbf{Normalisierung} der Iterationenzanzahl mit der unteren Formel:

\begin{figure}
\centering
\includegraphics[width=0.7\linewidth]{img/farbstreifen}
\caption{Die verschiedenen Farbstreifen im Mandelbrot}
\label{fig:farbstreifen}
\end{figure}
$$mu = n + 1 - \frac{\log(\log(|z_n|) / \log(exponent))}{\log(bailout)} $$

, wobei $mu$ der normalisierte Wert, $n$ die Iterationenanzahl, $z_n$ ist 0 nach $n$ Iterationen, $exponent$ der Exponent der Mandelbrot-Funktion $z = z^n + c$, und $bailout$ unserer Fluchtradius ist. \cite{linas}

Geben wir anstatt $n$ den Wert $mu$ der Palettenfunktion weiter, bekommen wir ein geglättetes Bild des Mandelbrots (Abb. \ref{fig:mandelbrot_smooth})

\begin{figure}
\centering
\includegraphics[width=\linewidth]{img/mandelbrot_smooth}
\caption{Ein Bild des Mandelbrots ohne Farbstreifen}
\label{fig:mandelbrot_smooth}
\end{figure}


\subsection{Xaos-Algorithmus}
Benutzen wir die obigen Funktionen, können wir einen simplen Mandelbrot-Zoomer bilden mit folgender Schleife:
\begin{itemize}
\item Skalierungsfaktor \lstinline|scale| vergrößern (um herauszuzoomen) oder verkleinern (um heranzuzoomen)
\item \lstinline|xcoords| (die Realteile / Spalten) und \lstinline|ycoords| (die Imaginärteile / Reihen) aus \lstinline|scale| berechnen
\item Pixel \lstinline|(x,y)| repräsentiert dann die Nummer $xcoords|x| + i \cdot ycoords|y| \rightarrow$  Iterationenanzahl $\rightarrow$ Farbe
\item Wiederholen
\end{itemize}
Wir merken aber, dass beim Zoomen der Bildschirm nicht so stark sich ändert. Viele Punkte bzw. Pixel vom letzten Frame tauchen im neuen Frame wieder auf. Betrachtet man die Spalten z.B. beim 2x Zoomen:
 \\ 
 
\begin{tabular}{c c c c c c c c}
$O_1$ &  &$O_2$  &  & $O_3$  &  & $O_4$ &  \\
\hline
$X_1$ & $X_2$ & $X_3$ & $X_4$ & $X_5$  & $X_6$ & $X_7$  & $X_8$  \\
\end{tabular}
 \\
 \\
, wobei $O_1... O_4$ alte Spalten und $X_1 ... X_8$ neue Spalten sind. Schon lässt sich sehen, dass wir die Spalten $X_1, X_3, X_5, X_7$ nicht erneut berechnen müssen. Stattdessen können dafür die Pixel von den entsprechenden Spalten $O_1 , O_2, O_3, O_4$ ''wiederverwendet'' werden. Das ist auch die grundlegende Idee des Xaos-Algorithmus: wir versuchen, beim Rendern eines neuen Frames neue Spalten/Reihen durch alte Spalte/Reihen zu approximieren. Nur Punkte mit keinen guten Approximierungen sind erneut zu berechnen \cite{xaos}.

Die Implementierung im Programm folgt der von MandelbrotSSE auf GitHub \cite{sse}:
\begin{enumerate}
\item Sucht für jede neue Zeile/Spalte eine alte Zeile/Spalte, die sie am bestens approximiert:
	\begin{lstlisting}[language=python]
	# WIDTH: Anzahl der Spalten
	
	for i in range(WIDTH):
		diff_best = infinity 
		id_best = -1 
		# Sucht nur bei seinen Nachbarn
		for j in range(i - 40, i + 40):
			diff = abs(xcoords[i] - old_xcoords[j])
			if diff < diff_best:
				id_best = j
				diff_best = diff
					
		pairs[i].id_orig = i
		pairs[i].id_best = id_best
		pairs[i].dist = diff_best
	\end{lstlisting}
	
	Mach das gleiche für Zeilen.
	
\item Füllt die Lookup-Tabellen aus:
	\begin{lstlisting}[language=python]
	# Sortiert die Paare danach, wie gut die Approximierung ist
	# Die schlechtesten Appr. sind am Anfang.
	pairs.sort_on('dist').reverse()
	
	for i in range(WIDTH):
		id_orig = pairs[i].id_orig
		id_best = pairs[i].id_best
		
		if i < REDRAW_PERCENT / 100 * WIDTH:
			# Die schlechtesten Paare bzw. Spalten sind erneut zu berechnen
			xlookup[id_orig] = -1
		else: 
			# Sonst: approximiere neue Spalte id_orig mit alter Spalte id_best
			xlookup[id_orig] = id_best
			xcoords[id_orig] = old_xcoords[id_best]
	\end{lstlisting}
	
	Mach das gleiche für Spalten
	
\item Rendert den neuen Frame mithilfe der Lookup-Tabellen und des alten Frames:
	\begin{lstlisting}[language=python]
	for x in range(WIDTH):
		for y in range(HEIGHT):
			x_best = xlookup[x]
			y_best = ylookup[y]
			if x_best != -1 and y_best != -1:
				# Eine Appr. fuer die Spalte und Reihe ist gefunden
				# Benutzt den entsprechenden Pixel vom alten Frame
				frame[x,y] = old_frame[x_best, y_best]
			else:
				real = xcoords[x]
				imag = ycoords[y]
				frame[x,y] = calculate_mandelbrot(real, imag)
	\end{lstlisting}
\end{enumerate}

Durch Anwendung des Xaos-Algorithmus wurde das Programm mindestens um 2-3 Mal beschleunigt. Was aber überraschend ist, dass obwohl er bei der CPU sehr gut funktioniert, scheiter der Algorithmus komplett bei der GPU. Es liegt wohl daran, dass die GPU sehr wenig RAM hat, um schnell auf den Array \lstinline|old_frame| zuzugreifen. 
\subsection{Andere Optimierungen}
\subsubsection{Orbit-Erkennung}
Wenn beim Iterieren $z$ einen vorherigen Wert wieder trifft, heißt es, dass $z$ in einer Schleife ist und daher immer begrenzt bleibt. Z.B: 
 
$z_0 \rightarrow z_1 \rightarrow z_2 \rightarrow z_1 \rightarrow z_2 \rightarrow z_1 \rightarrow z_2 \rightarrow ...$
 
 
Wenn wir dies erkennen können, können wir die Iterationsschleife abbrechen und die Rechenarbeit sparen . Bei meisten Punkten im Mandelbrot geschieht dies auch sehr früh (Benutzen Sie den Orbit-Modus des Programms, um dies zu sehen). Im Folgenden ist eine Implementierung davon, mit Credits an LocklessInc \cite{lockless}:
\begin{lstlisting}[language=python]
def find_iter_with_orbit_detection(c, max_iter):
	period = 8
	iter = 0
	while period != max_iter:
		mem = z
		period = period*2
		if period > max_iter: period = max_iter
		
		while iter < period:
			iter = iter + 1
			z = z**2 + c 
			
			if abs(z) > 4: return iter 
			if z == mem: return max_iter
				
\end{lstlisting}
Der obige Code prüft auf Perioden mit Länge 8, dann 16, 32, ...

\subsubsection{Potenz durch Quadrieren}
Da die eingebauten Taichi Funktionen für komplexe Zahlen viel zu langsam sind, muss leider Potenzierung $z^n$ (n ist ganzzahlig \& positiv) selber implementiert werden. Ein naiver Approach wäre, $n$ Mal mit z mit sich selbst zu multiplizieren ($n$ Schritte). Wir können aber stattdessen Potenzierung wie folgt rekursiv definieren: 
\begin{itemize}
\item $z^n = (z^{n/2})^2$ für gerade $n$ 
\item $z^n = (z^{n-1}).z$ für ungerade $n$
\end{itemize}
Beispielsweise wäre $z^{17} = (((z^2)^2)^2)^2 . z$, mit vier Mal Quadrieren und ein Mal Multiplizieren, anstatt 17 Multiplikationen. Allgemein wird die Anzahl der Schritte von $n$ auf $\log n$ reduziert. Für größe $n$ bleibt dies allerdings noch zu langsam, aber es ist für dieses Projekt hinreichend, wobei maximal nur $z^{10}$ berechnet wird.

\section{Schwachstellen \& Verbesserungen}
Alles in allem bin ich zufrieden mit der Performanz des Programms. Dennoch gibt es auch einige Probleme, die wegen Mangel der Zeit oder technischer Fähigkeit nicht gelöst wurden:
\subsection{Optik}
\begin{itemize}
\item Beim Zoomen sieht man oft einen glitzernden Effekt. Dies ist leider ein Nebeneffekt des Renderns mit dem Xaos-Algorithmus.
\item Bei bestimmten Regionen des Mandelbrots ist das Bildrauschen sehr stark ausgeprägt, da keine Antialiasing implementiert wurde.
\end{itemize}

\subsection{Geschwindigkeit}
\begin{itemize}
\item Trotz der Orbit-Erkennung verlangsamt sich / laggt das Programm erheblich beim Rendern von Punkten innerhalb der Mandelbrot-Menge.
\item Statt taichi kann \textbf{pyopengl} benutzt werden, um direkt mit Shader bzw. der GPU zu arbeiten für erhöhte Leistung.

\end{itemize}

\section{Fazit}
Zusammenfassend lässt sich sagen, dass dieses Projekt eine gute Lektion in Sachen der Parallelisierung, Computergrafik und Python im Allgemeinen. Ohne großen Verlust der Codelesbarkeit kann Python ziemlich leistungsfähig sein. Zukünftig wird eventuell noch Bildnachbearbeitung implementiert und ein neues Modul gesucht, um die GUI zu verbessern.
\printbibliography

\end{document} % This is the end of the document
